___TERMS_OF_SERVICE___

By creating or modifying this file you agree to Google Tag Manager's Community
Template Gallery Developer Terms of Service available at
https://developers.google.com/tag-manager/gallery-tos (or such other URL as
Google may provide), as modified from time to time.


___INFO___

{
  "displayName": "Reddit Conversions API",
  "description": "By using the Reddit Conversions API you agree to comply with and to be bound by the Reddit Advertiser Measurement Program Terms\n\nhttps://www.reddithelp.com/en/categories/advertising/policy-guideline",
  "id": "cvt_M6PJS",
  "type": "TAG",
  "version": 1,
  "brand": {
    "thumbnail": "data:image/png;base64,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\u003d",
    "displayName": "reddit",
    "id": "github.com_reddit"
  },
  "containerContexts": [
    "SERVER"
  ],
  "securityGroups": []
}


___TEMPLATE_PARAMETERS___

[
  {
    "help": "You can find your Pixel ID at \u003ca href\u003d\"https://ads.reddit.com/events-manager#pixel-onboarding/gtm\"\u003ehttps://ads.reddit.com/events-manager#pixel-onboarding/gtm\u003c/a\u003e",
    "valueValidators": [
      {
        "type": "NON_EMPTY"
      },
      {
        "args": [
          3,
          100
        ],
        "type": "STRING_LENGTH"
      },
      {
        "args": [
          "(t2_|a2_)[a-z0-9]+"
        ],
        "type": "REGEX"
      }
    ],
    "displayName": "Pixel ID",
    "simpleValueType": true,
    "name": "id",
    "type": "TEXT",
    "valueHint": "t2_***** or a2_*****",
    "notSetText": "Please provide your Reddit Ads Pixel ID."
  },
  {
    "macrosInSelect": true,
    "selectItems": [
      {
        "displayValue": "Page Visit",
        "value": "PageVisit"
      },
      {
        "displayValue": "View Content",
        "value": "ViewContent"
      },
      {
        "displayValue": "Search",
        "value": "Search"
      },
      {
        "displayValue": "Add to Cart",
        "value": "AddToCart"
      },
      {
        "displayValue": "Add To Wishlist",
        "value": "AddToWishlist"
      },
      {
        "displayValue": "Purchase",
        "value": "Purchase"
      },
      {
        "displayValue": "Lead",
        "value": "Lead"
      },
      {
        "displayValue": "Sign Up",
        "value": "SignUp"
      },
      {
        "value": "Custom",
        "displayValue": "Custom"
      }
    ],
    "displayName": "Event to Fire",
    "simpleValueType": true,
    "name": "eventType",
    "type": "SELECT"
  },
  {
    "type": "TEXT",
    "name": "customEventName",
    "displayName": "CustomEventName",
    "simpleValueType": true,
    "enablingConditions": [
      {
        "paramName": "eventType",
        "paramValue": "Custom",
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "TEXT",
    "name": "currency",
    "displayName": "Currency",
    "simpleValueType": true,
    "enablingConditions": [
      {
        "paramName": "eventType",
        "paramValue": "AddToCart",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "AddToWishlist",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Purchase",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "SignUp",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Lead",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Custom",
        "type": "EQUALS"
      }
    ],
    "help": "Currency should follow the ISO 4217 standard"
  },
  {
    "type": "TEXT",
    "name": "transactionValue",
    "displayName": "Transaction Value",
    "simpleValueType": true,
    "enablingConditions": [
      {
        "paramName": "eventType",
        "paramValue": "AddToCart",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "AddToWishlist",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Purchase",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "SignUp",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Lead",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Custom",
        "type": "EQUALS"
      }
    ],
    "help": "The value of the transaction as a decimal value of currency.  For example, a value of $10.99 USD should be entered as \"10.99\"."
  },
  {
    "type": "TEXT",
    "name": "itemCount",
    "displayName": "Item Count",
    "simpleValueType": true,
    "enablingConditions": [
      {
        "paramName": "eventType",
        "paramValue": "AddToCart",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "AddToWishlist",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Purchase",
        "type": "EQUALS"
      },
      {
        "paramName": "eventType",
        "paramValue": "Custom",
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "TEXT",
    "name": "conversionId",
    "displayName": "Conversion ID",
    "simpleValueType": true,
    "help": "Unique Conversion ID that corresponds to a distinct conversion event. Conversion ID is used for deduplication and prevents the same conversion event from being processed more than once if it is sent multiple times."
  },
  {
    "type": "TEXT",
    "name": "testId",
    "displayName": "Test ID",
    "simpleValueType": true,
    "optional": true,
    "help": "Enable this only for use with \u003ca href\u003d\"https://ads.reddit.com/events-manager/testing\"\u003eEvent Testing\u003c/a\u003e. \u003cstrong\u003eDisable in production!\u003c/strong\u003e Events with this setting enabled are rate-limited to max 10 events per second."
  },
  {
    "type": "CHECKBOX",
    "name": "enableFirstPartyCookies",
    "checkboxText": "Enable First Party Cookies",
    "simpleValueType": true,
    "defaultValue": true
  },
  {
    "type": "CHECKBOX",
    "name": "advancedMatching",
    "checkboxText": "Enable Advanced Matching",
    "simpleValueType": true
  },
  {
    "type": "GROUP",
    "name": "advancedMatchingGroup",
    "displayName": "Advanced Matching Parameters",
    "groupStyle": "ZIPPY_OPEN",
    "subParams": [
      {
        "type": "SIMPLE_TABLE",
        "name": "advancedMatchingParams",
        "displayName": "",
        "simpleTableColumns": [
          {
            "defaultValue": "",
            "displayName": "Parameter Name",
            "name": "name",
            "type": "SELECT",
            "selectItems": [
              {
                "value": "email",
                "displayValue": "Email"
              },
              {
                "value": "phone_number",
                "displayValue": "Phone Number"
              },
              {
                "value": "aaid",
                "displayValue": "AAID"
              },
              {
                "value": "idfa",
                "displayValue": "IDFA"
              },
              {
                "value": "externalId",
                "displayValue": "External ID"
              }
            ],
            "isUnique": true,
            "macrosInSelect": false
          },
          {
            "defaultValue": "",
            "displayName": "Parameter Value",
            "name": "value",
            "type": "TEXT",
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ]
          }
        ]
      }
    ],
    "enablingConditions": [
      {
        "paramName": "advancedMatching",
        "paramValue": true,
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "CHECKBOX",
    "name": "dataProcessingOptions",
    "checkboxText": "Enable Data Processing Options",
    "simpleValueType": true
  },
  {
    "type": "GROUP",
    "name": "dataProcessingOptionsGroup",
    "displayName": "Data Processing Parameters",
    "groupStyle": "ZIPPY_OPEN",
    "subParams": [
      {
        "type": "CHECKBOX",
        "name": "limitedDataUsageOptions",
        "checkboxText": "Enable Limited Data Usage options",
        "simpleValueType": true,
        "defaultValue": true
      },
      {
        "type": "GROUP",
        "name": "limitedDataUsageParams",
        "displayName": "Limited Data Usage Parameters",
        "groupStyle": "ZIPPY_OPEN",
        "subParams": [
          {
            "type": "TEXT",
            "name": "ldu_country",
            "displayName": "Country",
            "simpleValueType": true,
            "help": "Country Code of the user. We support ISO 3166-1 alpha-2 country codes, e.g. USA."
          },
          {
            "type": "TEXT",
            "name": "ldu_region",
            "displayName": "Region",
            "simpleValueType": true,
            "help": "Region Code of the user. We support ISO 3166-2 region code, e.g. USA-CA or just the region code without country prefix, e.g. CA."
          }
        ],
        "enablingConditions": [
          {
            "paramName": "limitedDataUsageOptions",
            "paramValue": true,
            "type": "EQUALS"
          }
        ]
      }
    ],
    "enablingConditions": [
      {
        "paramName": "dataProcessingOptions",
        "paramValue": true,
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "products",
    "displayName": "Product Information",
    "subParams": [
      {
        "type": "RADIO",
        "name": "productInputType",
        "displayName": "Input Type",
        "radioItems": [
          {
            "value": "entryManual",
            "displayValue": "Individual Entry",
            "help": "Configure product-level information using one row per unique product."
          },
          {
            "value": "entryJSON",
            "displayValue": "JSON Payload",
            "help": "Configure product-level information by submitting an array of unique products in JSON format."
          }
        ],
        "simpleValueType": true
      },
      {
        "type": "SIMPLE_TABLE",
        "name": "productsRows",
        "displayName": "Individual Entry",
        "simpleTableColumns": [
          {
            "defaultValue": "",
            "displayName": "Product ID",
            "name": "id",
            "type": "TEXT",
            "valueHint": "The item\u0027s ID in the catalog",
            "isUnique": false
          },
          {
            "defaultValue": "",
            "displayName": "Product Name",
            "name": "name",
            "type": "TEXT",
            "valueHint": ""
          },
          {
            "defaultValue": "",
            "displayName": "Product Category",
            "name": "category",
            "type": "TEXT",
            "valueHint": "For example, Google\u0027s product taxonomy",
            "isUnique": false
          }
        ],
        "help": "The Product ID and Product Category are required, but the Product Name is optional.",
        "enablingConditions": [
          {
            "paramName": "productInputType",
            "paramValue": "entryManual",
            "type": "EQUALS"
          }
        ]
      },
      {
        "type": "TEXT",
        "name": "productsJSON",
        "displayName": "JSON Payload",
        "simpleValueType": true,
        "enablingConditions": [
          {
            "paramName": "productInputType",
            "paramValue": "entryJSON",
            "type": "EQUALS"
          }
        ],
        "help": "The Product ID and Product Category are required, but the Product Name is optional. Format: [ { \"id\": \"Product_ID\", \"name\": \"Product_Name\",  \"category\": \"Product_Category\" }, ... ]"
      }
    ],
    "groupStyle": "ZIPPY_CLOSED"
  },
  {
    "type": "GROUP",
    "name": "authentication",
    "displayName": "Authentication",
    "groupStyle": "ZIPPY_OPEN",
    "subParams": [
      {
        "type": "TEXT",
        "name": "conversionToken",
        "displayName": "Conversion Access Token",
        "simpleValueType": true,
        "valueValidators": [
          {
            "type": "NON_EMPTY"
          }
        ],
        "notSetText": "Please provide a Conversion Access Token.",
        "help": "Generate this in your Reddit Ads account - \u003ca href\u003d\"https://business.reddithelp.com/helpcenter/s/article/conversion-access-token\"\u003ehttps://business.reddithelp.com/helpcenter/s/article/conversion-access-token\u003c/a\u003e"
      }
    ]
  }
]


___SANDBOXED_JS_FOR_SERVER___

const JSON = require("JSON");
const Promise = require("Promise");
const encodeUriComponent = require("encodeUriComponent");
const getAllEventData = require("getAllEventData");
const getContainerVersion = require("getContainerVersion");
const getCookieValues = require("getCookieValues");
const getTimestampMillis = require("getTimestampMillis");
const getType = require("getType");
const logToConsole = require("logToConsole");
const makeInteger = require("makeInteger");
const makeNumber = require("makeNumber");
const makeString = require("makeString");
const makeTableMap = require("makeTableMap");
const parseUrl = require("parseUrl");
const sendHttpRequest = require("sendHttpRequest");

const TEMPLATE_VERSION = "2.0.0";

const TAG_VERSION = "v2.1";

const PIXEL_ID = encodeUriComponent(data.id);

const CONVERSION_TOKEN = data.conversionToken;

const containerVersion = getContainerVersion();
const containerId = containerVersion.containerId;

const MILLIS_IN_SECONDS = 1000;

const CONSTANTS = {
  ACCESS_TOKEN_EXPIRY_THRESHOLD_MILLIS: 60 * MILLIS_IN_SECONDS,

  API_USER_AGENT:
    "SGTM:" + containerId + ":" + TAG_VERSION + " (by " + PIXEL_ID + ")",

  CAPI_PARTNER: "SGTM",

  API_CONVERSIONS_ENDPOINT: "https://ads-api.reddit.com/api/v3/pixels/" + PIXEL_ID + "/conversion_events",
  API_CONVERSIONS_ENDPOINT_TIMEOUT: 3 * MILLIS_IN_SECONDS,

  CLICK_ID_COOKIE_NAME: "_rdt_cid",
  CLICK_ID_EVENT_NAME: "rdt_cid",
  CLICK_ID_URL_NAME: "rdt_cid",

  EMAIL_COOKIE_NAME: "_rdt_em",

  UUID_COOKIE_NAME: "_rdt_uuid",
  UUID_EVENT_NAME: "rdt_uuid",
  
  TRACKING_TYPE_MAPPING: {
    "PageVisit": "PAGE_VISIT",
    "ViewContent": "VIEW_CONTENT",
    "Search": "SEARCH",
    "AddToCart": "ADD_TO_CART",
    "AddToWishlist": "ADD_TO_WISHLIST",
    "Purchase": "PURCHASE",
    "Lead": "LEAD",
    "SignUp": "SIGN_UP",
    "Custom": "CUSTOM"
  }
};

const DEFAULT_EVENT_TIME = getTimestampMillis();

const TEST_ID = data.testId;

function collectEventData() {
  return Promise.create((resolve) => {
    const eventData = getAllEventData();
    const config = data;

    const integrationPartner =
      eventData.integration_partner || CONSTANTS.CAPI_PARTNER;

    if (TEST_ID) {
      logToConsole("data", data);
      logToConsole("eventData", eventData);
    }

    const eventAtMs = DEFAULT_EVENT_TIME;
    const eventType = getEventType(integrationPartner);

    const clickId = getClickId(eventData);

    const eventMetadata = getEventMetadata(config, eventData);

    const userData = getUserData(eventData);

    const mappedEventData = {
      event_at: eventAtMs,
      action_source: "WEBSITE",
      type: eventType,
      click_id: clickId,
      metadata: eventMetadata,
      user: userData,
    };
    if (TEST_ID) {
      logToConsole("mappedEventData", mappedEventData);
    }

    return resolve({
      eventPayload: mappedEventData,
      partner: integrationPartner,
    });
  });
}

function getEventType(integrationPartner) {
  return {
    tracking_type: integrationPartner === CONSTANTS.CAPI_PARTNER ? mapTrackingType(data.eventType) : data.eventType,
    custom_event_name: data.eventType === "Custom" ? data.customEventName : undefined,
  };
}

function mapTrackingType(name) {
  return CONSTANTS.TRACKING_TYPE_MAPPING[name];
}

function getClickId(eventData) {
  const clickId =
    getClickIdFromURL(eventData.page_location) ||
    getClickIdFromCookie() ||
    getClickIdFromEvent(eventData);
  if (clickId) {
    return clickId;
  }
}

function getClickIdFromURL(pageUrl) {
  const url = parseUrl(pageUrl);
  if (!url || !url.searchParams) {
    return;
  }

  const clickIds = url.searchParams[CONSTANTS.CLICK_ID_URL_NAME];

  // =0 click IDs
  if (!clickIds) {
    return;
  }

  let clickId;
  if (getType(clickIds) === "string") {
    // =1 click IDs
    clickId = makeString(clickIds);
  } else if (getType(clickIds) === "array") {
    // >1 click IDs
    // use first value
    clickId = makeString(clickIds[0]);
  } else {
    return;
  }

  if (TEST_ID) {
    logToConsole("url-cid", clickId);
  }

  return clickId;
}

function getClickIdFromEvent(eventData) {
  const clickId = eventData[CONSTANTS.CLICK_ID_EVENT_NAME];
  if (TEST_ID) {
    logToConsole("event-cid", clickId);
  }

  if (clickId) {
    return makeString(clickId);
  }
}

function getClickIdFromCookie() {
  const clickIds = getCookieValues(CONSTANTS.CLICK_ID_COOKIE_NAME);
  if (TEST_ID) {
    logToConsole("cookie-cid", clickIds);
  }

  // =0 click IDs
  if (!clickIds || clickIds.length === 0) {
    return;
  }

  // >=1 click IDs
  // use first value
  const clickID = clickIds[0];

  if (clickID) {
    return makeString(clickID);
  }
}

var formatCategories = function (item) {
  var categories = [];
  var categoryLevels = [
    "item_category",
    "item_category2",
    "item_category3",
    "item_category4",
    "item_category5",
  ];

  for (var i = 0; i < categoryLevels.length; i++) {
    var key = categoryLevels[i];
    if (item[key]) {
      var value = item[key].trim();
      if (value !== "") {
        categories.push(value);
      }
    }
  }

  return categories.length > 0 ? categories.join(" > ") : null;
};

function processEcommerceItems(items) {
  if (!items || items.length === 0) {
    return {
      products: null,
      itemCount: 0,
    };
  }

  let processedItems = [];
  let processedItemCount = 0;

  for (const item of items) {
    if (!item) return;

    let product = {};
    if (item.item_id) product.id = makeString(item.item_id);
    if (item.item_name) product.name = makeString(item.item_name);
    let itemCategory = formatCategories(item);
    if (itemCategory) product.category = makeString(itemCategory);

    processedItems.push(product);
    let itemQuantity =
      item.quantity !== undefined && item.quantity !== null ? makeInteger(item.quantity) : 1;
    processedItemCount += itemQuantity;
  }

  return {
    products: processedItems,
    itemCount: processedItemCount,
  };
}

function processProductData(config, eventData) {
  let finalProducts;
  let finalItemCount;

  // Determine the item count with priority: UI > Web Manual
  finalItemCount = config.itemCount || eventData.item_count;

  // Prioritize manually configured products from config (UI)
  if (
    config.productInputType === "entryManual" &&
    config.productsRows &&
    config.productsRows.length > 0
  ) {
    finalProducts = config.productsRows;
  } else if (config.productInputType === "entryJSON" && config.productsJSON) {
    finalProducts = JSON.parse(config.productsJSON);
    if (!finalProducts) {
      logToConsole("Products JSON payload is malformed.");
      return null;
    }
  } else if (eventData.ecommerce_items) {
    // Fallback to handle ecommerce items from web container
    const ecommerceItems = JSON.parse(eventData.ecommerce_items);
    const ecommerceResult = processEcommerceItems(ecommerceItems);
    finalProducts = ecommerceResult.products;
    finalItemCount = ecommerceResult.itemCount;
  } else if (eventData.product_data) {
    // Fallback to handle raw product data from web container
    if (getType(eventData.product_data) === "string") {
      finalProducts = JSON.parse(eventData.product_data);
      if (!finalProducts) {
        logToConsole(
          "Product data JSON payload is malformed. Products will be omitted."
        );
        finalProducts = null;
      }
    } else if (getType(eventData.product_data) === "array") {
      finalProducts = eventData.product_data;
    } else {
      logToConsole(
        "Product data is not in expected format. Products will be omitted."
      );
      finalProducts = null;
    }
  }

  return {
    products: finalProducts,
    itemCount: finalItemCount,
  };
}

function getEventMetadata(config, eventData) {
  let eventMetadata = {};

  const conversionId = config.conversionId || eventData.conversion_id;
  if (conversionId) {
    eventMetadata.conversion_id = makeString(conversionId);
  }

  let transactionValue;
  if (
    config.transactionValue !== undefined &&
    config.transactionValue !== null
  ) {
    transactionValue = config.transactionValue;
  } else if (eventData.value !== undefined && eventData.value !== null) {
    transactionValue = eventData.value;
  }

  if (transactionValue !== undefined && transactionValue !== null) {
    eventMetadata.value = makeNumber(transactionValue);
  }

  const currency = config.currency || eventData.currency;
  if (currency) {
    eventMetadata.currency = makeString(currency);
  }

  const productData = processProductData(config, eventData);

  if (productData === null) {
    return data.gtmOnFailure();
  }

  if (productData.products && productData.products.length > 0) {
    eventMetadata.products = productData.products;
  }

  if (productData.itemCount !== undefined && productData.itemCount !== null) {
    eventMetadata.item_count = makeInteger(productData.itemCount);
  }

  return eventMetadata;
}

function getUUIDFromCookie() {
  const uuids = getCookieValues(CONSTANTS.UUID_COOKIE_NAME);
  if (TEST_ID) {
    logToConsole("cookie-uuids", uuids);
  }

  if (!uuids || uuids.length === 0) {
    return;
  }

  let oldestUUID;
  let oldestTs;
  for (let uuid of uuids) {
    // Find oldest UUID set using timestamp portion
    // cookie format: timestamp_in_ms.UUIDv4
    const parts = uuid.split(".");
    if (parts && parts.length === 2) {
      const ts = makeNumber(parts[0]);
      if (!oldestTs || (ts && ts < oldestTs)) {
        oldestTs = ts;
        oldestUUID = parts[1];
      }
    }
  }

  if (oldestUUID) {
    if (TEST_ID) {
      logToConsole("cookie-uuid-oldest", oldestUUID);
    }
    return makeString(oldestUUID);
  }
}

function getUUIDFromEvent(eventData) {
  const uuid = eventData[CONSTANTS.UUID_EVENT_NAME];
  if (TEST_ID) {
    logToConsole("event-uuid", uuid);
  }

  if (uuid) {
    return makeString(uuid);
  }
}

function getEmailFromCookie() {
  const emails = getCookieValues(CONSTANTS.EMAIL_COOKIE_NAME);
  if (TEST_ID) {
    logToConsole("cookie-email", emails);
  }

  // =0 emails
  if (!emails || emails.length === 0) {
    return;
  }

  // >=1 emails
  // use first value
  const email = emails[0];

  if (email) {
    return makeString(email);
  }
}

function getUserData(eventData) {
  let user = {};

  if (data.enableFirstPartyCookies) {
    const uuid = getUUIDFromCookie() || getUUIDFromEvent(eventData);
    if (uuid) {
      user.uuid = uuid;
    }
  }

  if (eventData.user_data) {
    const email =
      eventData.user_data.email_address ||
      eventData.user_data.sha256_email_address;
    if (email) {
      user.email = makeString(email);
    }

    const phoneNumber =
      eventData.user_data.phone_number ||
      eventData.user_data.sha256_phone_number;
    if (phoneNumber) {
      user.phone_number = makeString(phoneNumber);
    }
  }

  if (
    data.advancedMatching &&
    data.advancedMatchingParams &&
    data.advancedMatchingParams.length > 0
  ) {
    const params = makeTableMap(data.advancedMatchingParams, "name", "value");

    if (params) {
      if (params.aaid) {
        user.aaid = makeString(params.aaid);
      }
      if (params.email) {
        user.email = makeString(params.email) || getEmailFromCookie();
      }
      if (params.externalId) {
        user.external_id = makeString(params.externalId);
      }
      if (params.idfa) {
        user.idfa = makeString(params.idfa);
      }
      if (params.phone_number) {
        user.phone_number = makeString(params.phone_number);
      }
    }
  }

  if (data.dataProcessingOptions) {
    let dataProcessing;

    if (data.limitedDataUsageOptions) {
      dataProcessing = {
        modes: ["LDU"],
      };
      if (data.ldu_country) {
        dataProcessing.country = makeString(data.ldu_country);
      }
      if (data.ldu_region) {
        dataProcessing.region = makeString(data.ldu_region);
      }
    }

    if (dataProcessing) {
      user.data_processing_options = dataProcessing;
    }
  }

  if (eventData.ip_override) {
    user.ip_address = eventData.ip_override;
  }

  if (eventData.user_agent) {
    user.user_agent = eventData.user_agent;
  }

  if (eventData.screen_resolution) {
    let dimensions = eventData.screen_resolution.split("x");
    if (dimensions.length === 2) {
      user.screen_dimensions = {
        width: makeInteger(dimensions[0]),
        height: makeInteger(dimensions[1]),
      };
    }
  }

  return user;
}

function sendCAPIRequest(requestData) {
  const eventPayload = requestData.eventPayload;
  const integrationPartner = requestData.partner;

  const headers = {
    "Content-Type": "application/json",
    "User-Agent": CONSTANTS.API_USER_AGENT,
    Authorization: "Bearer " + CONVERSION_TOKEN,
  };

  const body = {
    data: {
      test_id: TEST_ID,
      events: [eventPayload],
      partner: integrationPartner,
      partner_version: TEMPLATE_VERSION,
    }
  };

  if (TEST_ID) {
    logToConsole("url", CONSTANTS.API_CONVERSIONS_ENDPOINT);
    logToConsole("headers", headers);
    logToConsole("body", body);
  }

  return sendHttpRequest(
    CONSTANTS.API_CONVERSIONS_ENDPOINT,
    {
      method: "POST",
      timeout: CONSTANTS.API_CONVERSIONS_ENDPOINT_TIMEOUT,
      headers: headers,
    },
    JSON.stringify(body)
  );
}

function handleCAPIResponse(response) {
  const statusCode = response.statusCode;
  const body = JSON.parse(response.body);

  if (statusCode >= 200 && statusCode < 300) {
    if (TEST_ID) {
      logToConsole(
        "Conversion API request succeeded with message:",
        body.data.message
      );
    }

    return data.gtmOnSuccess();
  } else {
    logToConsole("Conversion API request failed with status code:", statusCode);
    logToConsole("Conversion API request failed with error:", body.error);
    return data.gtmOnFailure();
  }
}

return collectEventData().then(sendCAPIRequest).then(handleCAPIResponse);


___SERVER_PERMISSIONS___

[
  {
    "instance": {
      "key": {
        "publicId": "logging",
        "versionId": "1"
      },
      "param": [
        {
          "key": "environments",
          "value": {
            "type": 1,
            "string": "all"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "send_http",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedUrls",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "urls",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "https://ads-api.reddit.com/api/*"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "get_cookies",
        "versionId": "1"
      },
      "param": [
        {
          "key": "cookieAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "cookieNames",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "_rdt_uuid"
              },
              {
                "type": 1,
                "string": "_rdt_cid"
              },
              {
                "type": 1,
                "string": "_rdt_em"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_event_data",
        "versionId": "1"
      },
      "param": [
        {
          "key": "eventDataAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_container_data",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  }
]


___TESTS___

scenarios:
- name: Verify default populated event_at and partner info
  code: "const testData = {};\n\nverifyCAPI((requestUrl, requestOptions, requestBody)\
    \ => {\n  assertThat(JSON.parse(requestBody).data.events[0].event_at).isDefined();\n\
    \  assertThat(JSON.parse(requestBody).data.partner).isEqualTo('SGTM');\n  assertThat(JSON.parse(requestBody).data.partner_version).isEqualTo('2.0.0');\n\
    \  \n});\n\nrunCode(testData);"
- name: When CAPI returns 200, gtmOnSuccess
  code: |-
    const testData = {};

    mock('sendHttpRequest', (requestUrl, requestOptions, requestBody) => {
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200, body: JSON.stringify(mockSuccessResponse)});
      });
    });

    runCode(testData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasCalled();
      assertApi('gtmOnFailure').wasNotCalled();
    });
- name: When CAPI returns 400, gtmOnFailure
  code: |-
    const testData = {};

    const mockErrorResponse = {
      "error": {
        "code": 401,
        "message": "No bearer token provided."
      }
    };

    mock('sendHttpRequest', (requestUrl, requestOptions, requestBody) => {
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 400, body: JSON.stringify(mockErrorResponse)});
      });
    });

    runCode(testData);

    callLater(() => {
      assertApi('gtmOnSuccess').wasNotCalled();
      assertApi('gtmOnFailure').wasCalled();
    });
- name: Given pixel ID, verify endpoint path
  code: "const testData = {\n  id: 't2_123',\n};\n\nconst expectedUrl = 'https://ads-api.reddit.com/api/v3/pixels/'\
    \ + testData.id + '/conversion_events';\n\nverifyCAPI((requestUrl, requestOptions,\
    \ requestBody) => {\n  assertThat(requestUrl).isEqualTo(expectedUrl);\n  \n});\n\
    \nrunCode(testData);"
- name: Given standard eventType, verify tracking_type
  code: |-
    const testData = {
      eventType: 'PageVisit',
    };

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].type.tracking_type).isEqualTo('PAGE_VISIT');
      assertThat(JSON.parse(requestBody).data.events[0].type.custom_event_name).isUndefined();
    });

    runCode(testData);
- name: Given custom eventType, verify custom_event_name
  code: |-
    const testData = {
      eventType: 'Custom',
      customEventName: 'test_custom_event',
    };

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].type.tracking_type).isEqualTo('CUSTOM');
      assertThat(JSON.parse(requestBody).data.events[0].type.custom_event_name).isEqualTo('test_custom_event');
    });

    runCode(testData);
- name: Given AUTOMATIC_GTM partner, verify tracking type not overriden
  code: |-
    const testData = {
      eventType: 'add_to_cart',
    };

    mock('getAllEventData', () => {
      return {
        integration_partner: "AUTOMATIC_GTM"
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].type.tracking_type).isEqualTo('add_to_cart');
      assertThat(JSON.parse(requestBody).data.events[0].type.custom_event_name).isUndefined();
    });

    runCode(testData);
- name: Given event click ID, verify click_id
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        rdt_cid: 'test_click_id',
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].click_id).isEqualTo('test_click_id');
    });

    runCode(testData);
- name: Given event and cookie click ID, verify cookie overrides event
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        rdt_cid: 'test_click_id',
      };
    });

    mock('getCookieValues', (key) => {
      if (key == "_rdt_cid") {
        return [
          'click_id_1',
          'click_id_2',
        ];
      }
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].click_id).isEqualTo('click_id_1');
    });

    runCode(testData);
- name: Given event, cookie and URL click ID, verify URL overrides all
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        rdt_cid: 'test_click_id',
        page_location: "https://sample.com/?rdt_cid=url_click_id"
      };
    });

    mock('getCookieValues', (key) => {
      if (key == "_rdt_cid") {
        return [
          'click_id_1',
          'click_id_2',
        ];
      }
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].click_id).isEqualTo('url_click_id');
    });

    runCode(testData);
- name: Given only event currency, verify currency in metadata
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        currency: 'USD',
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.currency).isEqualTo('USD');
    });

    runCode(testData);
- name: Given both tag and event currency, verify tag definition overrides event
  code: |-
    const testData = {
      currency: 'USD',
    };

    mock('getAllEventData', () => {
      return {
        currency: 'CAD',
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.currency).isEqualTo('USD');
    });

    runCode(testData);
- name: Given only event value, verify value in metadata
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        value: 10.99,
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.value).isEqualTo(10.99);
    });

    runCode(testData);
- name: Given both tag trasactionValue and event value, verify tag definition overrides
    event
  code: |-
    const testData = {
      transactionValue: 10.99,
    };

    mock('getAllEventData', () => {
      return {
        value: 1.99,
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.value).isEqualTo(10.99);
    });

    runCode(testData);
- name: Given only event item_count, verify item_count in metadata
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        item_count: 2
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.item_count).isEqualTo(2);
    });

    runCode(testData);
- name: Given both tag itemCount and event item_count, verify tag defeinition overrides
    event
  code: |-
    const testData = {
      itemCount: 2
    };

    mock('getAllEventData', () => {
      return {
        item_count: 1
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.item_count).isEqualTo(2);
    });

    runCode(testData);
- name: Given event ecommerce_items, verify products override event item_count
  code: |-
    const testData = {};

    const items = [
      {
        item_id: '1',
        item_name: 'product_a',
        item_category: 'a1',
        item_category2: 'a2',
        item_category3: 'a3',
        item_category4: 'a4',
        item_category5: 'a5'
      },
      {
        item_id: '2',
        item_name: 'product_b',
        item_category: 'b1',
        item_category2: 'b2'
      }
    ];

    mock('getAllEventData', () => {
      return {
        item_count: 1,
        ecommerce_items: JSON.stringify(items)
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.item_count).isEqualTo(2);
    });

    runCode(testData);
- name: Given event ecommerce_items, verify products override tag itemCount
  code: |-
    const testData = {
      itemCount: 1
    };

    const items = [
      {
        item_id: '1',
        item_name: 'product_a',
        item_category: 'a1',
        item_category2: 'a2',
        item_category3: 'a3',
        item_category4: 'a4',
        item_category5: 'a5'
      },
      {
        item_id: '2',
        item_name: 'product_b',
        item_category: 'b1',
        item_category2: 'b2'
      }
    ];

    mock('getAllEventData', () => {
      return {
        ecommerce_items: JSON.stringify(items)
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.item_count).isEqualTo(2);
    });

    runCode(testData);
- name: Given tag productsRows, verify metadata products
  code: |-
    const testData = {
      productInputType: 'entryManual',
      productsRows: [
        {
          id: '1',
          name: 'product_a',
          category: 'a1 > a2 > a3 > a4 > a5'
        },
        {
          id: '2',
          name: 'product_b',
          category: 'b1 > b2'
        }
      ]
    };

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].id).isEqualTo('1');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].name).isEqualTo('product_a');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].category).isEqualTo('a1 > a2 > a3 > a4 > a5');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].id).isEqualTo('2');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].name).isEqualTo('product_b');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].category).isEqualTo('b1 > b2');
    });

    runCode(testData);
- name: Given tag productsJSON, verify metadata products
  code: |-
    const products = [
      {
        id: '1',
        name: 'product_a',
        category: 'a1 > a2 > a3 > a4 > a5'
      },
      {
        id: '2',
        name: 'product_b',
        category: 'b1 > b2'
      }
    ];

    const testData = {
      productInputType: 'entryJSON',
      productsJSON: JSON.stringify(products)
    };

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].id).isEqualTo('1');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].name).isEqualTo('product_a');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].category).isEqualTo('a1 > a2 > a3 > a4 > a5');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].id).isEqualTo('2');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].name).isEqualTo('product_b');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].category).isEqualTo('b1 > b2');
    });

    runCode(testData);
- name: Given event ecommerce_items, verify metadata products
  code: |-
    const testData = {};

    const items = [
      {
        item_id: '1',
        item_name: 'product_a',
        item_category: 'a1',
        item_category2: 'a2',
        item_category3: 'a3',
        item_category4: 'a4',
        item_category5: 'a5'
      },
      {
        item_id: '2',
        item_name: 'product_b',
        item_category: 'b1',
        item_category2: 'b2'
      }
    ];

    mock('getAllEventData', () => {
      return {
        ecommerce_items: JSON.stringify(items)
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].id).isEqualTo('1');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].name).isEqualTo('product_a');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].category).isEqualTo('a1 > a2 > a3 > a4 > a5');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].id).isEqualTo('2');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].name).isEqualTo('product_b');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].category).isEqualTo('b1 > b2');
    });

    runCode(testData);
- name: Given event product_data string, verify metadata products
  code: |-
    const products = [
      {
        id: '1',
        name: 'product_a',
        category: 'a1 > a2 > a3 > a4 > a5'
      },
      {
        id: '2',
        name: 'product_b',
        category: 'b1 > b2'
      }
    ];

    const testData = {};

    mock('getAllEventData', () => {
      return {
        product_data: JSON.stringify(products)
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].id).isEqualTo('1');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].name).isEqualTo('product_a');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].category).isEqualTo('a1 > a2 > a3 > a4 > a5');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].id).isEqualTo('2');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].name).isEqualTo('product_b');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].category).isEqualTo('b1 > b2');
    });

    runCode(testData);
- name: Given event product_data array, verify metadata products
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        product_data: [
          {
            id: '1',
            name: 'product_a',
            category: 'a1 > a2 > a3 > a4 > a5'
          },
          {
            id: '2',
            name: 'product_b',
            category: 'b1 > b2'
          }
        ]
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].id).isEqualTo('1');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].name).isEqualTo('product_a');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[0].category).isEqualTo('a1 > a2 > a3 > a4 > a5');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].id).isEqualTo('2');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].name).isEqualTo('product_b');
      assertThat(JSON.parse(requestBody).data.events[0].metadata.products[1].category).isEqualTo('b1 > b2');
    });

    runCode(testData);
- name: Given event UUID, verify user
  code: |-
    const testData = {
      enableFirstPartyCookies: true,
    };

    mock('getAllEventData', () => {
      return {
        rdt_uuid: "test_uuid"
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.uuid).isEqualTo('test_uuid');
    });

    runCode(testData);
- name: Given both cookie and event UUID, verify cookie oldest UUID overrides event
  code: |-
    const testData = {
      enableFirstPartyCookies: true,
    };

    mock('getAllEventData', () => {
      return {
        rdt_uuid: "dummy_uuid"
      };
    });

    mock('getCookieValues', (key) => {
      if (key == "_rdt_uuid") {
        return [
          '2.new_uuid',
          '1.oldest_uuid',
        ];
      }
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.uuid).isEqualTo('oldest_uuid');
    });

    runCode(testData);
- name: Given event email and phone number, verify user has both
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        user_data: {
          email_address: "dummy@example.com",
          phone_number: "+11234567890",
        }
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.email).isEqualTo('dummy@example.com');
      assertThat(JSON.parse(requestBody).data.events[0].user.phone_number).isEqualTo('+11234567890');
    });

    runCode(testData);
- name: Given both tag and event user data, verify tag params override event
  code: |-
    const testData = {
      advancedMatching: true,
      advancedMatchingParams: [
        {
          name: "email",
          value: "dummy@example.com",
        },
        {
          name: "phone_number",
          value: "+11234567890",
        }
      ]
    };

    mock('getAllEventData', () => {
      return {
        user_data: {
          email_address: "dummy@test.com",
          phone_number: "+10987654321",
        }
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.email).isEqualTo('dummy@example.com');
      assertThat(JSON.parse(requestBody).data.events[0].user.phone_number).isEqualTo('+11234567890');
    });

    runCode(testData);
- name: Given advanced matching IDs, verify user has all IDs
  code: |-
    const testData = {
      advancedMatching: true,
      advancedMatchingParams: [
        {
          name: "aaid",
          value: "test_aaid",
        },
        {
          name: "externalId",
          value: "test_external_id",
        },
        {
          name: "idfa",
          value: "test_idfa",
        }
      ]
    };

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.aaid).isEqualTo('test_aaid');
      assertThat(JSON.parse(requestBody).data.events[0].user.external_id).isEqualTo('test_external_id');
      assertThat(JSON.parse(requestBody).data.events[0].user.idfa).isEqualTo('test_idfa');
    });

    runCode(testData);
- name: Given data processing options, verify user has data processing options
  code: |-
    const testData = {
      dataProcessingOptions: true,
      limitedDataUsageOptions: true,
      ldu_country: "US",
      ldu_region: "US-CA",
    };

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.data_processing_options.modes[0]).isEqualTo('LDU');
      assertThat(JSON.parse(requestBody).data.events[0].user.data_processing_options.country).isEqualTo('US');
      assertThat(JSON.parse(requestBody).data.events[0].user.data_processing_options.region).isEqualTo('US-CA');
    });

    runCode(testData);
- name: Given event ip_override, verify user has ip_address
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        ip_override: "123.456.78.90",
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.ip_address).isEqualTo('123.456.78.90');
    });

    runCode(testData);
- name: Given event user_agent, verify user has user_agent
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        user_agent: "test_user_agent",
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.user_agent).isEqualTo('test_user_agent');
    });

    runCode(testData);
- name: Given event screen_resolution, verify user has screen_dimensions
  code: |-
    const testData = {};

    mock('getAllEventData', () => {
      return {
        screen_resolution: "1920x1080",
      };
    });

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.screen_dimensions.width).isEqualTo(1920);
      assertThat(JSON.parse(requestBody).data.events[0].user.screen_dimensions.height).isEqualTo(1080);
    });

    runCode(testData);
- name: Given conversion access token, verify request header has bearer token
  code: |-
    const testData = {
      conversionToken: "test_capi_token"
    };

    verifyCAPI(function(requestUrl, requestOptions, requestBody) {
      assertThat(requestOptions.headers.Authorization).isEqualTo('Bearer ' + testData.conversionToken);
    });

    runCode(testData);
- name: Given no email in user_data, verify email is not set in user object
  code: |
    const testData = {};

    mock("getAllEventData", () => {
      return {
        user_data: {
          phone_number: "+11234567890",
        },
      };
    });

    verifyCAPI(function (requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.email).isUndefined();
      assertThat(
        JSON.parse(requestBody).data.events[0].user.phone_number
      ).isEqualTo("+11234567890");
    });

    runCode(testData);
- name: Given no phone_number in user_data, verify phone_number is not set in user
    object
  code: |
    const testData = {};

    mock("getAllEventData", () => {
      return {
        user_data: {
          email_address: "dummy@example.com",
        },
      };
    });

    verifyCAPI(function (requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.email).isEqualTo(
        "dummy@example.com"
      );
      assertThat(
        JSON.parse(requestBody).data.events[0].user.phone_number
      ).isUndefined();
    });

    runCode(testData);
- name: Given empty user_data object, verify email and phone_number are not set
  code: |
    const testData = {};

    mock("getAllEventData", () => {
      return {
        user_data: {},
      };
    });

    verifyCAPI(function (requestUrl, requestOptions, requestBody) {
      assertThat(JSON.parse(requestBody).data.events[0].user.email).isUndefined();
      assertThat(
        JSON.parse(requestBody).data.events[0].user.phone_number
      ).isUndefined();
    });

    runCode(testData);
setup: |-
  const JSON = require('JSON');
  const Promise = require('Promise');
  const callLater = require('callLater');

  const mockSuccessResponse = {
    "data": {
      "message": "Successfully processed 1 conversion events."
    }
  };

  function verifyCAPI(verify) {
    return mock('sendHttpRequest', (requestUrl, requestOptions, requestBody) => {
      verify(requestUrl, requestOptions, requestBody);
      return Promise.create((resolve, reject) => {
        resolve({ statusCode: 200, body: JSON.stringify(mockSuccessResponse)});
      });
    });
  }


___NOTES___

Created on 01/11/2023, 00:00:00
Updated on 29/11/2023, 00:00:00


